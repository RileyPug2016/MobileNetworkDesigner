<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Network Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .workspace {
            touch-action: none;
        }
        .device {
            cursor: grab;
            touch-action: none;
            user-select: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: absolute;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .device.dragging {
            cursor: grabbing;
            z-index: 1000;
            transform: scale(1.1);
        }
        .device.selected-for-connection {
             box-shadow: 0 0 30px rgba(79, 70, 229, 0.9);
        }
        .palette-device {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .palette-device:active {
            transform: scale(0.95);
        }
        .config-panel {
            transition: transform 0.3s ease-in-out;
        }
        .config-panel.open {
            transform: translateX(0);
        }
        .config-panel.closed {
            transform: translateX(100%);
        }
        .custom-modal {
            display: none;
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .custom-modal.show {
            display: flex;
        }
        .tab-btn {
            transition: all 0.2s ease;
        }
        .tab-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        .connection-label {
            position: absolute;
            background-color: rgba(31, 41, 55, 0.8);
            color: #d1d5db;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            pointer-events: none;
            user-select: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-gray-800/50 backdrop-blur-sm shadow-md p-3 flex justify-between items-center z-20 border-b border-gray-700">
        <h1 class="text-xl font-bold text-indigo-400">Network Simulator</h1>
        <div id="toolbar" class="flex items-center space-x-2 sm:space-x-4">
            <button id="connect-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 sm:px-4 rounded-lg flex items-center space-x-2 transition-all duration-200 transform hover:scale-105">
                <i class="fas fa-link"></i>
                <span class="hidden sm:inline">Connect</span>
            </button>
             <button id="ping-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 sm:px-4 rounded-lg flex items-center space-x-2 transition-all duration-200 transform hover:scale-105">
                <i class="fas fa-network-wired"></i>
                 <span class="hidden sm:inline">Ping</span>
            </button>
            <button id="delete-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 sm:px-4 rounded-lg flex items-center space-x-2 transition-all duration-200 transform hover:scale-105">
                <i class="fas fa-trash"></i>
                 <span class="hidden sm:inline">Delete</span>
            </button>
        </div>
    </header>

    <div class="flex flex-grow overflow-hidden">
        <!-- Device Palette -->
        <aside id="device-palette" class="w-24 bg-gray-800 p-2 flex flex-col items-center space-y-4 border-r border-gray-700">
            <div class="palette-device text-center w-full p-2 rounded-lg hover:bg-gray-700" data-type="router">
                <div id="router-icon-template" class="w-12 h-12 mx-auto pointer-events-none"></div>
                <span class="text-xs font-semibold">Router</span>
            </div>
            <div class="palette-device text-center w-full p-2 rounded-lg hover:bg-gray-700" data-type="switch">
                 <div id="switch-icon-template" class="w-12 h-12 mx-auto pointer-events-none"></div>
                <span class="text-xs font-semibold">Switch</span>
            </div>
            <div class="palette-device text-center w-full p-2 rounded-lg hover:bg-gray-700" data-type="pc">
                 <div id="pc-icon-template" class="w-12 h-12 mx-auto pointer-events-none"></div>
                <span class="text-xs font-semibold">PC</span>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="flex-grow relative">
            <div id="workspace" class="w-full h-full absolute top-0 left-0 bg-gray-900 overflow-hidden">
                <svg id="connections-svg" class="absolute top-0 left-0 w-full h-full pointer-events-none"></svg>
                <div id="label-container"></div>
            </div>
        </main>
    </div>


    <!-- Configuration Panel -->
    <aside id="config-panel" class="config-panel closed fixed top-0 right-0 h-full w-full sm:w-96 bg-gray-800/80 backdrop-blur-md shadow-2xl z-30 p-6 border-l border-gray-700 overflow-y-auto">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold text-indigo-400" id="config-title">Configuration</h2>
            <button id="close-panel-btn" class="text-gray-400 hover:text-white transition-colors">
                <i class="fas fa-times fa-2x"></i>
            </button>
        </div>
        <div id="config-content">
            <p class="text-gray-400">Select a device to configure.</p>
        </div>
    </aside>
    
    <!-- Modals -->
    <div id="ping-modal" class="custom-modal">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 sm:p-8 w-11/12 max-w-md">
            <h2 class="text-2xl font-bold mb-4 text-indigo-400">Ping Utility</h2>
            <div class="space-y-4">
                <div>
                    <label for="ping-source" class="block text-sm font-medium text-gray-300">Source IP</label>
                    <input type="text" id="ping-source" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm p-2">
                </div>
                <div>
                    <label for="ping-dest" class="block text-sm font-medium text-gray-300">Destination IP</label>
                    <input type="text" id="ping-dest" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm p-2">
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-4">
                <button id="cancel-ping-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="execute-ping-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Ping</button>
            </div>
            <pre id="ping-output" class="mt-4 bg-gray-900 text-green-400 p-4 rounded-md h-40 overflow-y-auto text-sm whitespace-pre-wrap"></pre>
        </div>
    </div>
    <div id="alert-modal" class="custom-modal">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-11/12 max-w-sm text-center">
            <p id="alert-message" class="text-lg mb-6"></p>
            <button id="alert-ok-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg">OK</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const workspace = document.getElementById('workspace');
            const devicePalette = document.getElementById('device-palette');
            const connectBtn = document.getElementById('connect-btn');
            const deleteBtn = document.getElementById('delete-btn');
            const connectionsSvg = document.getElementById('connections-svg');
            const labelContainer = document.getElementById('label-container');
            const configPanel = document.getElementById('config-panel');
            const closePanelBtn = document.getElementById('close-panel-btn');
            const configContent = document.getElementById('config-content');
            const configTitle = document.getElementById('config-title');
            const pingBtn = document.getElementById('ping-btn');
            const pingModal = document.getElementById('ping-modal');
            const cancelPingBtn = document.getElementById('cancel-ping-btn');
            const executePingBtn = document.getElementById('execute-ping-btn');
            const pingSourceInput = document.getElementById('ping-source');
            const pingDestInput = document.getElementById('ping-dest');
            const pingOutput = document.getElementById('ping-output');
            const alertModal = document.getElementById('alert-modal');
            const alertMessage = document.getElementById('alert-message');
            const alertOkBtn = document.getElementById('alert-ok-btn');

            // --- State ---
            let devices = [];
            let connections = [];
            let deviceIdCounter = 0;
            let selectedDevice = null;
            let isConnecting = false;
            let isDeleting = false;
            let connectionStartDevice = null;
            let tempLine = null;
            const MAC_TABLE_TIMEOUT = 300000; // 5 minutes in ms

            // --- SVG Icons ---
            const icons = {
                router: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 6a3 3 0 0 0-3-3H8a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h8a3 3 0 0 0 3-3V6Zm-2 0H7a1 1 0 0 1 0-2h10a1 1 0 0 1 0 2z" fill="#9ca3af"/><path d="M12 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4zM8 10h1v1H8v-1zm2 0h1v1h-1v-1zm2 0h1v1h-1v-1zm2 0h1v1h-1v-1z" fill="#4f46e5"/></svg>`,
                switch: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2zM7 15H5v-2h2v2zm4 0H9v-2h2v2zm4 0h-2v-2h2v2z" fill="#9ca3af"/><path d="M17.5 10.5 16 9v3l1.5-1.5zM6.5 10.5 8 9v3L6.5 10.5z" fill="#3b82f6"/></svg>`,
                pc: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20 18c1.1 0 1.99-.9 1.99-2L22 6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2H0v2h24v-2h-4zM4 6h16v10H4V6z" fill="#9ca3af"/></svg>`
            };
            document.getElementById('router-icon-template').innerHTML = icons.router;
            document.getElementById('switch-icon-template').innerHTML = icons.switch;
            document.getElementById('pc-icon-template').innerHTML = icons.pc;


            // --- Custom Alert ---
            function showAlert(message) {
                alertMessage.textContent = message;
                alertModal.classList.add('show');
            }
            alertOkBtn.addEventListener('click', () => alertModal.classList.remove('show'));

            // --- Device Management ---
            function createDevice(type, x, y) {
                const id = deviceIdCounter++;
                const deviceData = {
                    id: id,
                    type: type,
                    x: x,
                    y: y,
                    name: `${type.charAt(0).toUpperCase()}${id}`,
                    interfaces: {},
                };
                
                if (type === 'router') {
                    for (let i = 0; i < 4; i++) {
                        const ifName = `eth0/${i}`;
                        deviceData.interfaces[ifName] = { 
                            mac: `00:00:00:00:${id.toString().padStart(2, '0')}:${i.toString().padStart(2, '0')}`,
                            connectedTo: null, ip: '', cidr: ''
                        };
                    }
                    deviceData.routingTable = [];
                } else if (type === 'switch') {
                    for (let i = 0; i < 8; i++) {
                        const ifName = `fa0/${i}`;
                        deviceData.interfaces[ifName] = { 
                            mac: `00:00:00:00:${id.toString().padStart(2, '0')}:${i.toString().padStart(2, '0')}`,
                            connectedTo: null, mode: 'access', vlan: 1
                        };
                    }
                    deviceData.macAddressTable = [];
                    deviceData.vlans = [{id: 1, name: 'default'}];
                } else if (type === 'pc') {
                    deviceData.interfaces['eth0'] = {
                        mac: `00:00:00:00:${id.toString().padStart(2, '0')}:00`,
                        connectedTo: null, ip: '', cidr: '', gateway: ''
                    };
                }

                deviceData.el = createDeviceElement(deviceData);
                devices.push(deviceData);
                workspace.appendChild(deviceData.el);
                setupDeviceEventListeners(deviceData);
                if(type === 'router') updateRoutingTable(deviceData);
            }

            function createDeviceElement(device) {
                const el = document.createElement('div');
                el.id = `device-${device.id}`;
                el.className = `device`;
                el.style.left = `${device.x}px`;
                el.style.top = `${device.y}px`;
                el.innerHTML = `
                    ${icons[device.type]}
                    <div class="absolute text-center -bottom-6 text-sm font-semibold">${device.name}</div>
                `;
                return el;
            }

            document.querySelectorAll('.palette-device').forEach(paletteDevice => {
                paletteDevice.addEventListener('dblclick', (e) => {
                    const type = e.currentTarget.dataset.type;
                    const rect = workspace.getBoundingClientRect();
                    const x = (rect.width / 2 - 40) + (Math.random() * 100 - 50);
                    const y = (rect.height / 2 - 40) + (Math.random() * 100 - 50);
                    createDevice(type, x, y);
                });

                let lastTapTime = 0;
                paletteDevice.addEventListener('touchstart', (e) => {
                    const currentTime = new Date().getTime();
                    if (currentTime - lastTapTime < 300) {
                        e.preventDefault();
                        const type = e.currentTarget.dataset.type;
                        const rect = workspace.getBoundingClientRect();
                        const x = (rect.width / 2 - 40) + (Math.random() * 100 - 50);
                        const y = (rect.height / 2 - 40) + (Math.random() * 100 - 50);
                        createDevice(type, x, y);
                        lastTapTime = 0;
                    } else {
                        lastTapTime = currentTime;
                    }
                });
            });


            function setupDeviceEventListeners(deviceData) {
                const deviceEl = deviceData.el;
                
                const startInteraction = (e) => {
                    if (isConnecting || isDeleting) {
                        e.preventDefault();
                        e.stopPropagation();
                        handleDeviceClick(deviceData);
                        return;
                    }

                    let isDragging = false, hasMoved = false;
                    e.preventDefault();
                    isDragging = true;
                    deviceEl.classList.add('dragging');
                    const event = e.touches ? e.touches[0] : e;
                    const startX = event.clientX;
                    const startY = event.clientY;

                    const rect = deviceEl.getBoundingClientRect();
                    const offsetX = event.clientX - rect.left;
                    const offsetY = event.clientY - rect.top;
                    
                    const onDrag = (e) => {
                        if (!isDragging) return;
                        
                        const moveEvent = e.touches ? e.touches[0] : e;
                        const deltaX = Math.abs(moveEvent.clientX - startX);
                        const deltaY = Math.abs(moveEvent.clientY - startY);

                        if (deltaX > 5 || deltaY > 5) {
                           hasMoved = true;
                        }

                        if (hasMoved) {
                            e.preventDefault();
                            const workspaceRect = workspace.getBoundingClientRect();
                            deviceData.x = moveEvent.clientX - workspaceRect.left - offsetX;
                            deviceData.y = moveEvent.clientY - workspaceRect.top - offsetY;
                            deviceEl.style.left = `${deviceData.x}px`;
                            deviceEl.style.top = `${deviceData.y}px`;
                            updateConnections();
                        }
                    };
                    
                    const stopDrag = () => {
                        isDragging = false;
                        deviceEl.classList.remove('dragging');
                        document.removeEventListener('mousemove', onDrag);
                        document.removeEventListener('touchmove', onDrag);
                        document.removeEventListener('mouseup', stopDrag);
                        document.removeEventListener('touchend', stopDrag);
                        if (!hasMoved) {
                            handleDeviceClick(deviceData);
                        }
                    };

                    document.addEventListener('mousemove', onDrag);
                    document.addEventListener('touchmove', onDrag, { passive: false });
                    document.addEventListener('mouseup', stopDrag);
                    document.addEventListener('touchend', stopDrag);
                };

                deviceEl.addEventListener('mousedown', startInteraction);
                deviceEl.addEventListener('touchstart', startInteraction, { passive: false });
            }

            function handleDeviceClick(deviceData) {
                 if (isDeleting) {
                    deleteDevice(deviceData);
                    toggleDeleteMode(false);
                 } else if (isConnecting) {
                    if (!connectionStartDevice) {
                        connectionStartDevice = deviceData;
                        deviceData.el.classList.add('selected-for-connection');
                        tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        tempLine.setAttribute('stroke', '#f59e0b');
                        tempLine.setAttribute('stroke-width', '3');
                        tempLine.setAttribute('stroke-dasharray', '5,5');
                        connectionsSvg.appendChild(tempLine);

                        const moveListener = (e) => {
                            const event = e.touches ? e.touches[0] : e;
                            const startPos = getDeviceCenter(connectionStartDevice);
                            tempLine.setAttribute('x1', startPos.x);
                            tempLine.setAttribute('y1', startPos.y);
                            tempLine.setAttribute('x2', event.clientX);
                            tempLine.setAttribute('y2', event.clientY);
                        };
                        document.addEventListener('mousemove', moveListener);
                        document.addEventListener('touchmove', moveListener);
                        document.tempMoveListener = moveListener;

                    } else {
                        if (connectionStartDevice.id !== deviceData.id) {
                            createConnection(connectionStartDevice, deviceData);
                        }
                        toggleConnectionMode(false);
                    }
                } else {
                    openConfigPanel(deviceData);
                }
            }
            
            // --- Connection Management ---
            connectBtn.addEventListener('click', () => toggleConnectionMode());
            deleteBtn.addEventListener('click', () => toggleDeleteMode());

            function toggleConnectionMode(forceState = null) {
                if (isDeleting) toggleDeleteMode(false);
                isConnecting = forceState !== null ? forceState : !isConnecting;
                if (isConnecting) {
                    connectBtn.classList.add('bg-yellow-400');
                    connectBtn.classList.remove('bg-yellow-600');
                    workspace.style.cursor = 'crosshair';
                } else {
                    connectBtn.classList.remove('bg-yellow-400');
                    connectBtn.classList.add('bg-yellow-600');
                    workspace.style.cursor = 'default';
                    resetConnectionState();
                }
            }

            function toggleDeleteMode(forceState = null) {
                if (isConnecting) toggleConnectionMode(false);
                isDeleting = forceState !== null ? forceState : !isDeleting;
                if (isDeleting) {
                    deleteBtn.classList.add('bg-red-400');
                    deleteBtn.classList.remove('bg-red-600');
                    workspace.style.cursor = 'not-allowed';
                } else {
                    deleteBtn.classList.remove('bg-red-400');
                    deleteBtn.classList.add('bg-red-600');
                    workspace.style.cursor = 'default';
                }
            }
            
            function resetConnectionState() {
                if (connectionStartDevice) {
                    connectionStartDevice.el.classList.remove('selected-for-connection');
                }
                connectionStartDevice = null;
                if (tempLine && tempLine.parentNode) {
                    connectionsSvg.removeChild(tempLine);
                }
                tempLine = null;
                if (document.tempMoveListener) {
                    document.removeEventListener('mousemove', document.tempMoveListener);
                    document.removeEventListener('touchmove', document.tempMoveListener);
                    delete document.tempMoveListener;
                }
            }

            function createConnection(dev1, dev2) {
                const existing = connections.find(c => (c.d1 === dev1.id && c.d2 === dev2.id) || (c.d1 === dev2.id && c.d2 === dev1.id));
                if (existing) return;

                const if1 = findEmptyInterface(dev1);
                const if2 = findEmptyInterface(dev2);

                if (if1 && if2) {
                    const label1El = document.createElement('div');
                    label1El.className = 'connection-label';
                    label1El.textContent = if1;
                    labelContainer.appendChild(label1El);

                    const label2El = document.createElement('div');
                    label2El.className = 'connection-label';
                    label2El.textContent = if2;
                    labelContainer.appendChild(label2El);

                    connections.push({ id: `${dev1.id}-${dev2.id}`, d1: dev1.id, if1: if1, d2: dev2.id, if2: if2, label1El, label2El });
                    dev1.interfaces[if1].connectedTo = { deviceId: dev2.id, interface: if2 };
                    dev2.interfaces[if2].connectedTo = { deviceId: dev1.id, interface: if1 };
                    updateConnections();
                } else {
                    showAlert('No available interfaces on one of the devices.');
                }
            }

            function findEmptyInterface(device) {
                return Object.keys(device.interfaces).find(ifName => !device.interfaces[ifName].connectedTo);
            }

            function getDeviceCenter(deviceData) {
                return { x: deviceData.x + 40, y: deviceData.y + 40 };
            }

            function updateConnections() {
                connectionsSvg.innerHTML = '';
                connections.forEach(conn => {
                    const d1 = devices.find(d => d.id === conn.d1);
                    const d2 = devices.find(d => d.id === conn.d2);
                    if (!d1 || !d2) return;
                    const pos1 = getDeviceCenter(d1);
                    const pos2 = getDeviceCenter(d2);
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', pos1.x);
                    line.setAttribute('y1', pos1.y);
                    line.setAttribute('x2', pos2.x);
                    line.setAttribute('y2', pos2.y);
                    line.setAttribute('stroke', '#4b5563');
                    line.setAttribute('stroke-width', '4');
                    connectionsSvg.appendChild(line);

                    const label1X = pos1.x + (pos2.x - pos1.x) * 0.15;
                    const label1Y = pos1.y + (pos2.y - pos1.y) * 0.15;
                    conn.label1El.style.left = `${label1X}px`;
                    conn.label1El.style.top = `${label1Y}px`;

                    const label2X = pos2.x + (pos1.x - pos2.x) * 0.15;
                    const label2Y = pos2.y + (pos1.y - pos2.y) * 0.15;
                    conn.label2El.style.left = `${label2X}px`;
                    conn.label2El.style.top = `${label2Y}px`;
                });
            }
            
            function deleteDevice(deviceToDelete) {
                const connectionsToRemove = connections.filter(c => c.d1 === deviceToDelete.id || c.d2 === deviceToDelete.id);
                connectionsToRemove.forEach(conn => {
                    const neighborId = conn.d1 === deviceToDelete.id ? conn.d2 : conn.d1;
                    const neighbor = devices.find(d => d.id === neighborId);
                    if (neighbor) {
                        const neighborInterfaceName = Object.keys(neighbor.interfaces).find(ifName => neighbor.interfaces[ifName].connectedTo?.deviceId === deviceToDelete.id);
                        if (neighborInterfaceName) {
                            neighbor.interfaces[neighborInterfaceName].connectedTo = null;
                        }
                    }
                    labelContainer.removeChild(conn.label1El);
                    labelContainer.removeChild(conn.label2El);
                });

                connections = connections.filter(c => c.d1 !== deviceToDelete.id && c.d2 !== deviceToDelete.id);
                devices = devices.filter(d => d.id !== deviceToDelete.id);
                workspace.removeChild(deviceToDelete.el);

                if (selectedDevice && selectedDevice.id === deviceToDelete.id) {
                    closePanelBtn.click();
                }

                updateConnections();
            }

            // --- Configuration Panel ---
            function openConfigPanel(deviceData) {
                selectedDevice = deviceData;
                configTitle.textContent = `${deviceData.name} Config`;
                if (deviceData.type === 'router') {
                    openRouterConfigPanel(deviceData);
                } else if (deviceData.type === 'switch') {
                    openSwitchConfigPanel(deviceData);
                } else if (deviceData.type === 'pc') {
                    openPcConfigPanel(deviceData);
                }
                configPanel.classList.remove('closed');
                configPanel.classList.add('open');
            }

            function openRouterConfigPanel(router) {
                let content = `<div class="space-y-4">`;
                for (const ifName in router.interfaces) {
                    const iface = router.interfaces[ifName];
                    content += `
                        <div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                            <p class="font-bold ${iface.connectedTo ? 'text-green-400' : 'text-red-400'}">${ifName}</p>
                            <div class="flex space-x-2 mt-2">
                                <input type="text" data-iface="${ifName}" data-prop="ip" value="${iface.ip}" placeholder="IP Address" class="w-2/3 bg-gray-800 rounded p-1 text-sm border border-gray-600">
                                <input type="text" data-iface="${ifName}" data-prop="cidr" value="${iface.cidr}" placeholder="/24" class="w-1/3 bg-gray-800 rounded p-1 text-sm border border-gray-600">
                            </div>
                        </div>`;
                }
                content += '</div>';

                content += '<h3 class="text-lg font-semibold mt-6 mb-2 text-gray-300">Routing Table</h3>';
                content += `<table class="w-full text-sm text-left text-gray-400">
                    <thead class="text-xs text-gray-300 uppercase bg-gray-700"><tr>
                        <th class="px-2 py-2">Type</th><th class="px-2 py-2">Network</th><th class="px-2 py-2">Next Hop</th><th class="px-2 py-2">Interface</th>
                    </tr></thead><tbody>`;
                router.routingTable.forEach(route => {
                    content += `<tr class="bg-gray-800 border-b border-gray-700">
                        <td class="px-2 py-2 font-medium ${route.type === 'C' ? 'text-green-400' : 'text-blue-400'}">${route.type}</td>
                        <td class="px-2 py-2">${route.network}/${route.cidr}</td>
                        <td class="px-2 py-2">${route.nextHop || 'N/A'}</td>
                        <td class="px-2 py-2">${route.interface}</td>
                    </tr>`;
                });
                content += '</tbody></table>';

                 content += '<h3 class="text-lg font-semibold mt-6 mb-2 text-gray-300">Add Static Route</h3>';
                 content += `<div id="static-route-form" class="space-y-2 text-sm">
                    <input type="text" id="route-network" placeholder="Network (e.g., 10.0.0.0)" class="w-full bg-gray-800 rounded p-1 border border-gray-600">
                    <input type="text" id="route-cidr" placeholder="CIDR (e.g., 8)" class="w-full bg-gray-800 rounded p-1 border border-gray-600">
                    <input type="text" id="route-nexthop" placeholder="Next Hop IP" class="w-full bg-gray-800 rounded p-1 border border-gray-600">
                    <button id="add-route-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Add Route</button>
                 </div>`;

                configContent.innerHTML = content;

                configContent.querySelector('#add-route-btn').addEventListener('click', () => {
                    const network = document.getElementById('route-network').value;
                    const cidr = document.getElementById('route-cidr').value;
                    const nextHop = document.getElementById('route-nexthop').value;
                    if (network && cidr && nextHop) {
                        addStaticRoute(router, network, cidr, nextHop);
                        openConfigPanel(router); // Refresh panel
                    }
                });
            }

            function openSwitchConfigPanel(sw) {
                let content = `
                    <div class="flex border-b border-gray-700 mb-4">
                        <button class="tab-btn flex-1 py-2 text-sm font-semibold text-gray-400 active" data-tab="ports">Ports</button>
                        <button class="tab-btn flex-1 py-2 text-sm font-semibold text-gray-400" data-tab="vlans">VLANs</button>
                        <button class="tab-btn flex-1 py-2 text-sm font-semibold text-gray-400" data-tab="mac">MAC Table</button>
                    </div>
                    <div id="tab-content"></div>
                `;
                configContent.innerHTML = content;
                
                configContent.querySelector('.tab-btn[data-tab="ports"]').addEventListener('click', () => showSwitchTab('ports', sw));
                configContent.querySelector('.tab-btn[data-tab="vlans"]').addEventListener('click', () => showSwitchTab('vlans', sw));
                configContent.querySelector('.tab-btn[data-tab="mac"]').addEventListener('click', () => showSwitchTab('mac', sw));
                
                showSwitchTab('ports', sw);
            }
            
            function openPcConfigPanel(pc) {
                const iface = pc.interfaces['eth0'];
                let content = `
                    <div class="space-y-4 bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                        <p class="font-bold ${iface.connectedTo ? 'text-green-400' : 'text-red-400'}">eth0</p>
                        <label class="block text-sm font-medium text-gray-300">IP Address</label>
                        <input type="text" data-iface="eth0" data-prop="ip" value="${iface.ip}" placeholder="192.168.1.10" class="w-full bg-gray-800 rounded p-1 text-sm border border-gray-600">
                        <label class="block text-sm font-medium text-gray-300">Subnet (CIDR)</label>
                        <input type="text" data-iface="eth0" data-prop="cidr" value="${iface.cidr}" placeholder="24" class="w-full bg-gray-800 rounded p-1 text-sm border border-gray-600">
                        <label class="block text-sm font-medium text-gray-300">Default Gateway</label>
                        <input type="text" data-iface="eth0" data-prop="gateway" value="${iface.gateway}" placeholder="192.168.1.1" class="w-full bg-gray-800 rounded p-1 text-sm border border-gray-600">
                    </div>
                `;
                configContent.innerHTML = content;
            }

            function showSwitchTab(tabId, sw) {
                const tabContent = configContent.querySelector('#tab-content');
                configContent.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                configContent.querySelector(`.tab-btn[data-tab="${tabId}"]`).classList.add('active');

                if (tabId === 'ports') {
                    let html = '<div class="space-y-2">';
                    for (const ifName in sw.interfaces) {
                        const iface = sw.interfaces[ifName];
                        html += `
                        <div class="grid grid-cols-3 gap-2 items-center text-sm">
                            <span class="${iface.connectedTo ? 'text-green-400' : 'text-red-400'}">${ifName}</span>
                            <select data-iface="${ifName}" data-prop="mode" class="bg-gray-700 rounded p-1 border border-gray-600">
                                <option value="access" ${iface.mode === 'access' ? 'selected' : ''}>Access</option>
                                <option value="trunk" ${iface.mode === 'trunk' ? 'selected' : ''}>Trunk</option>
                            </select>
                            <input type="text" data-iface="${ifName}" data-prop="vlan" value="${iface.vlan}" placeholder="VLAN ID" class="bg-gray-800 rounded p-1 border border-gray-600">
                        </div>`;
                    }
                    html += '</div>';
                    tabContent.innerHTML = html;
                } else if (tabId === 'vlans') {
                    tabContent.innerHTML = `<div class="text-gray-400">VLAN management UI is not yet implemented.</div>`;
                } else if (tabId === 'mac') {
                    let html = `<table class="w-full text-sm text-left text-gray-400">
                        <thead class="text-xs text-gray-300 uppercase bg-gray-700"><tr>
                            <th class="px-2 py-2">MAC</th><th class="px-2 py-2">Port</th><th class="px-2 py-2">VLAN</th>
                        </tr></thead><tbody>`;
                    sw.macAddressTable.forEach(entry => {
                        html += `<tr class="bg-gray-800 border-b border-gray-700">
                            <td class="px-2 py-2 font-mono">${entry.mac}</td>
                            <td class="px-2 py-2">${entry.interface}</td>
                            <td class="px-2 py-2">${entry.vlan}</td>
                        </tr>`;
                    });
                    html += `</tbody></table>`;
                    tabContent.innerHTML = html;
                }
            }

            configContent.addEventListener('change', (e) => {
                if (!selectedDevice) return;
                const iface = e.target.dataset.iface;
                const prop = e.target.dataset.prop;
                if (iface && prop) {
                    selectedDevice.interfaces[iface][prop] = e.target.value;
                    if (selectedDevice.type === 'router') {
                        updateAllRoutingTables();
                    }
                }
            });

            closePanelBtn.addEventListener('click', () => {
                configPanel.classList.remove('open');
                configPanel.classList.add('closed');
                selectedDevice = null;
            });
            
            // --- Routing & L2 Forwarding Logic ---
            function updateAllRoutingTables() {
                devices.filter(d => d.type === 'router').forEach(updateRoutingTable);
                if(selectedDevice && selectedDevice.type === 'router') openConfigPanel(selectedDevice);
            }

            function updateRoutingTable(router) {
                router.routingTable = router.routingTable.filter(route => route.type === 'S');
                Object.keys(router.interfaces).forEach((ifName) => {
                    const iface = router.interfaces[ifName];
                    if (iface.ip && iface.cidr) {
                        const network = getNetworkAddress(iface.ip, iface.cidr);
                        if (network) {
                            router.routingTable.push({
                                type: 'C', network: network, cidr: iface.cidr,
                                interface: ifName, nextHop: null
                            });
                        }
                    }
                });
            }

            function addStaticRoute(router, network, cidr, nextHop) {
                const outgoingInterface = findInterfaceForNextHop(router, nextHop);
                if (!outgoingInterface) {
                    showAlert(`Next hop ${nextHop} is not reachable from this router.`);
                    return;
                }
                router.routingTable.push({
                    type: 'S',
                    network,
                    cidr,
                    nextHop,
                    interface: outgoingInterface
                });
            }

            function findInterfaceForNextHop(router, nextHopIp) {
                for (const ifName in router.interfaces) {
                    const iface = router.interfaces[ifName];
                    if (iface.ip && iface.cidr) {
                        const network = getNetworkAddress(iface.ip, iface.cidr);
                        const nextHopNetwork = getNetworkAddress(nextHopIp, iface.cidr);
                        if (network === nextHopNetwork) {
                            return ifName;
                        }
                    }
                }
                return null;
            }
            
            // --- Ping & ARP Simulation ---
            pingBtn.addEventListener('click', () => {
                pingModal.classList.add('show');
                pingOutput.textContent = '';
            });
            cancelPingBtn.addEventListener('click', () => pingModal.classList.remove('show'));

            executePingBtn.addEventListener('click', async () => {
                const sourceIp = pingSourceInput.value;
                const destIp = pingDestInput.value;
                pingOutput.textContent = `Pinging ${destIp} from ${sourceIp}...\n\n`;

                const sourceDevice = findDeviceByIp(sourceIp);
                const destDevice = findDeviceByIp(destIp);

                if (!sourceDevice || !destDevice) {
                    pingOutput.textContent += `Error: Source or Destination IP not found.`;
                    return;
                }

                const { path, status } = await simulatePacketFlow(sourceDevice, destDevice, sourceIp, destIp);
                pingOutput.textContent += `\nResult: ${status}\n`;

                if (path && path.length > 0) {
                    pingOutput.textContent += `Path: ${path.map(d => d.name).join(' -> ')}\n`;
                    await animatePacketPath(path, '#4ade80');
                    
                    if (status === 'Success') {
                        const returnPath = [...path].reverse();
                        // Simulate return packet for MAC learning
                        await simulatePacketFlow(destDevice, sourceDevice, destIp, sourceIp, true);
                        await animatePacketPath(returnPath, '#3b82f6');
                    }
                }
                
                if (selectedDevice && selectedDevice.type === 'switch') {
                    openConfigPanel(selectedDevice);
                }

                if (status === 'Success') {
                    setTimeout(() => pingModal.classList.remove('show'), 1500);
                }
            });

            function learnMacAddress(switchDevice, mac, interfaceName) {
                if (!mac || !interfaceName) return;
                const vlan = switchDevice.interfaces[interfaceName]?.vlan || 1;
                const existingEntry = switchDevice.macAddressTable.find(entry => entry.mac === mac);
                if (existingEntry) {
                    existingEntry.interface = interfaceName;
                    existingEntry.vlan = vlan;
                    existingEntry.timestamp = Date.now();
                } else {
                    switchDevice.macAddressTable.push({ mac, interface: interfaceName, vlan, timestamp: Date.now() });
                }
            }

            async function simulatePacketFlow(source, destination, sourceIp, destIp, isReturn = false) {
                const sourceInterface = Object.values(source.interfaces).find(iface => iface.ip === sourceIp);
                const destInterface = Object.values(destination.interfaces).find(iface => iface.ip === destIp);

                let packet = {
                    sourceIp: sourceIp,
                    destIp: destIp,
                    sourceMac: sourceInterface ? sourceInterface.mac : Object.values(source.interfaces)[0].mac,
                    destMac: destInterface ? destInterface.mac : 'FF:FF:FF:FF:FF:FF',
                    ttl: 64
                };

                let path = [source];
                let currentDevice = source;
                let ingressPort = null;

                while (packet.ttl > 0) {
                    if (currentDevice.id === destination.id) {
                        return { path, status: 'Success' };
                    }
                    
                    if (currentDevice.type === 'switch' && ingressPort) {
                        learnMacAddress(currentDevice, packet.sourceMac, ingressPort);
                    }

                    const { nextHopDevice, egressPort } = findNextHop(currentDevice, packet, ingressPort);
                    
                    if (!nextHopDevice) {
                        return { path, status: `Destination Host Unreachable from ${currentDevice.name}` };
                    }
                    
                    if (nextHopDevice.type === 'router') {
                        packet.ttl--;
                    }
                    
                    if (packet.ttl <= 0) {
                        path.push(nextHopDevice);
                        return { path, status: `TTL Exceeded at ${nextHopDevice.name}` };
                    }
                    
                    const currentEgressIface = currentDevice.interfaces[egressPort];
                    if (!currentEgressIface || !currentEgressIface.connectedTo) {
                         return { path, status: `Routing Error: No connection on ${currentDevice.name} port ${egressPort}` };
                    }
                    ingressPort = currentEgressIface.connectedTo.interface;
                    
                    path.push(nextHopDevice);
                    currentDevice = nextHopDevice;
                }
                return { path, status: 'Error: Loop or unknown issue' };
            }

            function findNextHop(currentDevice, packet, ingressPort) {
                if (currentDevice.type === 'pc') {
                    const iface = currentDevice.interfaces.eth0;
                    if (!iface.connectedTo) return { nextHopDevice: null };
                    return { 
                        nextHopDevice: devices.find(d => d.id === iface.connectedTo.deviceId),
                        egressPort: 'eth0'
                    };
                }

                if (currentDevice.type === 'router') {
                    let bestMatch = null;
                    for (const route of currentDevice.routingTable) {
                        if (getNetworkAddress(packet.destIp, route.cidr) === route.network) {
                            if (!bestMatch || route.cidr > bestMatch.cidr) {
                                bestMatch = route;
                            }
                        }
                    }

                    if (bestMatch) {
                        const outgoingInterface = currentDevice.interfaces[bestMatch.interface];
                        if (outgoingInterface && outgoingInterface.connectedTo) {
                            return {
                                nextHopDevice: devices.find(d => d.id === outgoingInterface.connectedTo.deviceId),
                                egressPort: bestMatch.interface
                            };
                        }
                    }
                }

                if (currentDevice.type === 'switch') {
                    const macEntry = currentDevice.macAddressTable.find(entry => entry.mac === packet.destMac);
                    if (macEntry) {
                        const nextHopInterface = currentDevice.interfaces[macEntry.interface];
                        if (nextHopInterface && nextHopInterface.connectedTo) {
                            return { 
                                nextHopDevice: devices.find(d => d.id === nextHopInterface.connectedTo.deviceId),
                                egressPort: macEntry.interface
                            };
                        }
                    } else {
                        // Flood (simplified for pathfinding)
                        const destDevice = devices.find(d => Object.values(d.interfaces).some(i => i.mac === packet.destMac));
                        if (!destDevice) return { nextHopDevice: null };
                        const { path } = tracePath(currentDevice, destDevice, [currentDevice.id]);
                        if (path && path.length > 1) {
                            const egressPort = Object.keys(currentDevice.interfaces).find(ifName => currentDevice.interfaces[ifName].connectedTo?.deviceId === path[1].id);
                            return { nextHopDevice: path[1], egressPort };
                        }
                    }
                }
                return { nextHopDevice: null };
            }
            
            async function animatePacketPath(path, color) {
                for (let i = 0; i < path.length - 1; i++) {
                    await animatePacket(path[i], path[i+1], color);
                }
            }

            function animatePacket(startDevice, endDevice, color) {
                return new Promise(resolve => {
                    const startPos = getDeviceCenter(startDevice);
                    const endPos = getDeviceCenter(endDevice);
                    const packet = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    packet.setAttribute('r', '8');
                    packet.setAttribute('fill', color || '#4ade80');
                    connectionsSvg.appendChild(packet);

                    const duration = 500;
                    let startTime = null;
                    function step(timestamp) {
                        if (!startTime) startTime = timestamp;
                        const progress = Math.min((timestamp - startTime) / duration, 1);
                        packet.setAttribute('cx', startPos.x + (endPos.x - startPos.x) * progress);
                        packet.setAttribute('cy', startPos.y + (endPos.y - startPos.y) * progress);
                        if (progress < 1) {
                            requestAnimationFrame(step);
                        } else {
                            if (packet.parentNode) {
                                packet.parentNode.removeChild(packet);
                            }
                            resolve();
                        }
                    }
                    requestAnimationFrame(step);
                });
            }

            // --- IP Helper Functions ---
            function findDeviceByIp(ip) {
                return devices.find(device => 
                    (device.type === 'router' || device.type === 'pc') && 
                    Object.values(device.interfaces).some(iface => iface.ip === ip)
                );
            }

            function ipToLong(ip) {
                if (!ip) return 0;
                return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0) >>> 0;
            }

            function getNetworkAddress(ip, cidr) {
                if (!ip || !cidr || isNaN(parseInt(cidr))) return null;
                try {
                    const mask = (0xFFFFFFFF << (32 - cidr)) >>> 0;
                    const ipLong = ipToLong(ip);
                    const networkLong = ipLong & mask;
                    return [ (networkLong >>> 24), (networkLong >>> 16) & 255, (networkLong >>> 8) & 255, networkLong & 255 ].join('.');
                } catch(e) { return null; }
            }
            
            function tracePath(source, destination, visitedIds = []) {
                let queue = [[source, [source]]];
                let visited = new Set(visitedIds.map(id => id));
                visited.add(source.id);
                
                while (queue.length > 0) {
                    let [current, path] = queue.shift();
                    if (current.id === destination.id) {
                        return { path };
                    }
                    for (const ifName in current.interfaces) {
                        const iface = current.interfaces[ifName];
                        if (iface.connectedTo) {
                            const neighbor = devices.find(d => d.id === iface.connectedTo.deviceId);
                            if (neighbor && !visited.has(neighbor.id)) {
                                visited.add(neighbor.id);
                                queue.push([neighbor, [...path, neighbor]]);
                            }
                        }
                    }
                }
                return { path: null };
            }

            // --- Global Listeners ---
            workspace.addEventListener('mousedown', (e) => {
                if (e.target === workspace) {
                    if (isConnecting) toggleConnectionMode(false);
                    else if (isDeleting) toggleDeleteMode(false);
                    else if (configPanel.classList.contains('open')) closePanelBtn.click();
                }
            });

            window.addEventListener('resize', () => {
                devices.forEach(device => {
                    const maxX = workspace.clientWidth - 80 - 10;
                    const maxY = workspace.clientHeight - 80 - 10;
                    device.x = Math.max(10, Math.min(device.x, maxX));
                    device.y = Math.max(10, Math.min(device.y, maxY));
                    device.el.style.left = `${device.x}px`;
                    device.el.style.top = `${device.y}px`;
                });
                updateConnections();
            });
        });
    </script>
</body>
</html>
